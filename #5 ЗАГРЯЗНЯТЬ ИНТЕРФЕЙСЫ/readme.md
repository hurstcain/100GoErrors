# ОШИБКА #5: ЗАГРЯЗНЯТЬ ИНТЕРФЕЙСЫ

## Концепции

Интерфейсы используются для создания общих абстракций (набора методов), которые могут быть реализованы 
несколькими объектами. В Go интерфейсы реализуются неявно. 

Рассмотрим два классических примера интерфейсов в Go: _io.Reader_ и _io.Writer_. Пакет _io_ предоставляет абстракции для 
примитивов ввода/вывода. _io.Reader_ читает данные из источника, а _io.Writer_ — записывает данные в получатель.

```go
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}
```

Пользовательские реализации интерфейса _io.Reader_ должны принимать байтовый срез, заполняя его своими данными и возвращать 
либо количество прочитанных байтов, либо ошибку.

Пользовательские реализации _io.Writer_ должны записывать данные, поступающие из среза, в их получатель и возвращать либо 
количество записанных байтов, либо ошибку.

В чем смысл таких абстракций? Предположим, нужно реализовать функцию, которая будет копировать содержимое одного файла
в другой. Можно создать функцию, которая в качестве входных данных принимает два файла *_os.Files_. Либо создать
более общую функцию, которая принимает в качестве аргументов объекты, реализующие интерфейсы _io.Reader_ и _io.Writer_:

```go
func copySourceToDest(source io.Reader, dest io.Writer) error {
    // ...
}
```

Данная функция универсальна, и ее можно переиспользовать.


## Когда использовать интерфейсы

### Общее поведение

Если нужно, чтобы несколько типов реализовывали общее поведение, то можно это поведение заключить внутрь какого-то интерфейса.
В стандартной библиотеке есть пример: интерфейс из пакета _sort_:

```go
type Interface interface {
    Len() int // Число элементов
    Less(i, j int) bool // Сравнение двух элементов
    Swap(i, j int) // Перестановка двух элементов
}
```

Этот интерфейс имеет большой потенциал для переиспользования, так как включает в себя общее поведение для сортировки любой проиндексированной
коллекции. Например, в данном пакете есть функция, проверяющая, была ли коллекция уже отсортирована:

```go
func IsSorted(data Interface) bool {
    n := data.Len()
    for i := n — 1; i > 0; i-- {
        if data.Less(i, i-1) {
            return false
        }
    }  
    return true
}
```

Данная функция использует методы интерфейса _sort.Interface_, поэтому можно передать туда любую коллекцию, реализующую данный интерфейс.

### Снижение связанности (decoupling)

Еще один важный сценарий — отделение кода от его реализации. Если мы полагаемся на абстракцию вместо конкретной реализации, 
сама реализация может быть заменена на другую без необходимости менять код. Это и есть принцип подстановки Лисков 
(буква L в принципах SOLID Роберта Мартина).

Снижение связности помогает при написании юнит-тестов. Например, есть структура _CustomerService_, у нее есть метод _CreateNewCustomer_,
который создает нового потребителя и сохраняет его:

```go
type CustomerService struct {
    store mysql.Store // Зависит от конкретного способа реализации
}
    
func (cs CustomerService) CreateNewCustomer(id string) error {
    customer := Customer{id: id}
    return cs.store.StoreCustomer(customer)
}
```

Чтобы написать юнит тесты на данный метод, мы должны сгенерировать моки, так как экземпляр MySQL мы поднять не можем.
Таким образом, нам нужно отвязать структуру _CustomerService_ от конкретной реализации. Это делается через интерфейс:

```go
type customerStorer interface { // Создается абстракция хранилища
    StoreCustomer(Customer) error
}

type CustomerService struct {
    storer customerStorer // Отвязывает CustomerService от фактической реализации
}

func (cs CustomerService) CreateNewCustomer(id string) error {
    customer := Customer{id: id}
    return cs.storer.StoreCustomer(customer)
}
```

Сохранение созданного потребителя в базе теперь осуществляется через интерфейс, что дает большую гибкость в тестировании метода.
Например, мы можем:

* использовать конкретную реализацию в интеграционных тестах;
* применять в юнит-тестах имитации (моки) или любые другие тестовые дублеры;
* делать и то и другое.

### Ограничение поведения

Иногда может быть полезно ограничить поведение какого-либо типа.

Например, есть структура _IntConfig_, у которой определены два метода: _Get_ и _Set_.

```go
type IntConfig struct {
    // ...
}

func (c *IntConfig) Get() int {
    // Получить конфигурацию
}

func (c *IntConfig) Set(value int) {
    // Обновить конфигурацию
}
```

В нашем коде нас интересует только получение конфигурации, то есть использование метода _Get_. А метод _Set_ нам не нужен.
Тогда можно создать абстракцию, которая ограничивает поведение только получением значения конфигурации:

```go
type intConfigGetter interface {
    Get() int
}
```

Тогда в коде можно указать только _intConfigGetter_ вместо конкретной реализации:

```go
type Foo struct {
    threshold intConfigGetter
}

func NewFoo(threshold intConfigGetter) Foo { // Вводится геттер конфигурации
    return Foo{threshold: threshold}
}

func (f Foo) Bar() {
    threshold := f.threshold.Get() // Чтение конфигурации
    // ...
}
```


## Загрязнение интерфейса

Надо использовать интерфейсы там, где надо. А где не надо - не использовать...

Интерфейсы делают код более сложным для понимания. Иногда проще вызывать реализацию напрямую. Также иногда при вызове метода
через интерфейс можно столкнуться с оверхедом производительности. Требуется поиск в структуре данных хеш-таблицы, 
чтобы найти конкретный тип, на который указывает интерфейс. Но это не проблема во многих контекстах, поскольку оверхед
минимален.
